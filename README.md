# 3 - 4 - 5
Мы используем принципы DDD (Domain-Driven Design), выделяя ограниченные контексты
Идеальная архитектура стремится к высокой связанности внути и низкой снаружи сервиса
## Домены
- Пользователи (user service)
  Ответственность: Регистрация, аутентификация и управление профилями покупателей и продавцов
  Данные: Изолированная реляционная БД. Другие сервисы получают данные через API
- Каталог (catalog service)
  Ответственность: Управление ассортиментом для продавцов (добавление товара, цены, количества, остатки)
  Данные: Изолированная БД (Catalog DB). Только этот сервис может изменять остатки
- Заказы (order service)
  Ответственность: Оформление корзины, создание и трекинг статуса заказа
  Данные: Изолированная БД (Order DB). Хранит информацю о составе заказа
- Платежи (payment service)
  Ответственность: Расчет сумм, интеграция с внешними платежными шлюзами, учет платежей
  Данные: Изолированная БД (Payment DB). Хранит статусы транзакций
- Лента и рекомендации (feed service)
  Ответственность: Персонализированная выдача товаров
  Данные: Отдельная БД оптимизированная по чтение (NoSQL). Данные обновляются асинхронно при измен. в каталоге
- Уведомления (notification service)
  Ответственность: Отправка пуш уведомлений, email пользователям
  Данные: Шаблоны уведомлений и логи отправок. Работает с очередью сообщений
## Взаимодействие сервисов
- Синхронное (немедленное подтверждение операции)
  - От API Gateway к сервисам
  - Order service -> Catalog service
  - Order service -> User service
  
- Асинхронное (повышение отказаустойчивости)
  - Order service после создания заказа побликует событие OrderCreated
  - Payment service и Notification service выступают консьюмерами
  - Catalog service публикует событие об изменениях товаров для обнов. Feed service
  
# 6 - 7 - 8
## Модульный монолит
Вся система разрабатывается как единный процесс, но внутри есть логичиские модули с четкими границами
Плюсы
- Простая разработка для одной небольшой команды
- Отсутствие сетевых задережек при взаимодействиях модулей, ведь вызовы происходят локально
- Нет проблем с распределенными транзакциями
Минусы
- Сложность масштабирования (нужно масштабировать все целиком)
- Плохая отказаустойчивость
- Отсутвие паралельной разработки

## Микросервесная архитектура
Система разбита на мелкие сфокусированные сервисы вокруг бизнес-доменов, каждый из которых разветывается независимо и владеет собственной базой данных
Плюсы
- Гибкое масштабирование
- Высокая отказаустойчивость
- Сервисы могут быть написаны на разных языках и исп. разный БД
- Возможность независимой параллельной разработки
Минусы
- Сложная разработка и поддержка инфраструктуры
- Необходимость решать проблемы консистентности данных в рапределенных транзакциях
- Стоимость

## Выбраный вариант - микросервесная архитектура
Маркетплейс предполагает разную нагрузку. Например, ленту товаров пользователи будут чаще запрашивать, чем регистрацию. Микросервисная архитектура позволяет независимо масштабировать высоконагруженные узлы. Также, появляется отказаустойчивость. При падении сервиса уведомлений маркетплейс будет продалжать работать, продавать товары. При выборе микросервесной архитектуры мы избиагем антипаттерна "Общая связанность", выделяя для каждого микросервиса свою БД, что гарантирует инкапсуляцию данных и независимость команд. Принимаем проблему в виде усложнения поддержки инфраструктуры ради высокой доступности и возможности параллельной разработки

